# C4 „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂõ≥ - JavaScriptÁâà

**„Éâ„Ç≠„É•„É°„É≥„Éà„Éê„Éº„Ç∏„Éß„É≥**: 1.0.0  
**‰ΩúÊàêÊó•**: 2025-10-27  
**„Çπ„ÉÜ„Éº„Çø„Çπ**: Draft  
**ÂÆüË£ÖË®ÄË™û**: TypeScript on Node.js 20

---

## üìã Ê¶ÇË¶Å

C4„É¢„Éá„É´„ÅÆ„É¨„Éô„É´3„Å®„Åó„Å¶„ÄÅJavaScript(TypeScript)ÁâàAzure Functions„ÅÆÂÜÖÈÉ®„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊßãÈÄ†„ÇíË©≥Á¥∞„Å´Á§∫„Åó„Åæ„Åô„ÄÇ

**ÂØæË±°ÁØÑÂõ≤**:
- FileDetection FunctionÔºàTypeScriptÂÆüË£ÖÔºâ
- DataTransform FunctionÔºàTypeScriptÂÆüË£ÖÔºâ
- FileUploader FunctionÔºàTypeScriptÂÆüË£ÖÔºâ
- JobMonitor FunctionÔºàTypeScriptÂÆüË£ÖÔºâ
- ÂÖ±Êúâ„É¢„Ç∏„É•„Éº„É´ÔºàShared ModulesÔºâ

---

## üèóÔ∏è JavaScriptÁâàÂÖ®‰ΩìÊßãÊàê

### „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†

```
src/javascript/
‚îú‚îÄ‚îÄ functions/
‚îÇ   ‚îú‚îÄ‚îÄ file-detection/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts                  # „É°„Ç§„É≥„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.ts                # „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts                  # ÂûãÂÆöÁæ©
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ function.json
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ data-transform/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ transformer.ts            # Â§âÊèõ„Ç®„É≥„Ç∏„É≥
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ mapper.ts                 # „Éá„Éº„Çø„Éû„ÉÉ„Éî„É≥„Ç∞
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ file-uploader/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts                 # CSV Upload API„ÇØ„É©„Ç§„Ç¢„É≥„Éà
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ metadata-builder.ts       # metadata.jsonÁîüÊàê
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ job-monitor/
‚îÇ       ‚îú‚îÄ‚îÄ src/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ handler.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ reporter.ts               # „É¨„Éù„Éº„ÉàÁîüÊàê
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ
‚îú‚îÄ‚îÄ shared/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sds-models.ts             # SDS„Éá„Éº„Çø„É¢„Éá„É´
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ oneroster-models.ts       # OneRoster„Éá„Éº„Çø„É¢„Éá„É´
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ job-models.ts             # „Ç∏„Éß„ÉñÁÆ°ÁêÜ„É¢„Éá„É´
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger.ts                 # ÊßãÈÄ†Âåñ„É≠„Ç∞
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ azure-client.ts           # Azure SDKÁµ±Âêà
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ csv-parser.ts             # CSVÊìç‰Ωú
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validators.ts             # „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
‚îÇ   ‚îÇ   ‚îÇ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constants.ts                  # ÂÆöÊï∞ÂÆöÁæ©
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config.ts                     # Ë®≠ÂÆöÁÆ°ÁêÜ
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îî‚îÄ‚îÄ tsconfig.json
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ unit/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ file-detection.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data-transform.test.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ file-uploader.test.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ shared-utils.test.ts
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ integration/
‚îÇ       ‚îú‚îÄ‚îÄ e2e-flow.test.ts
‚îÇ       ‚îî‚îÄ‚îÄ api-integration.test.ts
‚îÇ
‚îú‚îÄ‚îÄ package.json                          # „ÉØ„Éº„ÇØ„Çπ„Éö„Éº„ÇπË®≠ÂÆö
‚îú‚îÄ‚îÄ tsconfig.json                         # TypeScriptÂÖ±ÈÄöË®≠ÂÆö
‚îú‚îÄ‚îÄ host.json                             # Function AppË®≠ÂÆö
‚îú‚îÄ‚îÄ local.settings.json                  # „É≠„Éº„Ç´„É´Ë®≠ÂÆöÔºàGitÈô§Â§ñÔºâ
‚îî‚îÄ‚îÄ README.md
```

### ‰∏ªË¶Å„É©„Ç§„Éñ„É©„É™

```json
{
  "dependencies": {
    "@azure/functions": "^4.5.0",
    "@azure/storage-blob": "^12.17.0",
    "@azure/data-tables": "^13.2.2",
    "@azure/identity": "^4.0.1",
    "@azure/keyvault-secrets": "^4.8.0",
    
    "csv-parse": "^5.5.3",
    "csv-stringify": "^6.4.5",
    "axios": "^1.6.2",
    "uuid": "^9.0.1",
    "zod": "^3.22.4",
    
    "date-fns": "^3.0.6"
  },
  "devDependencies": {
    "typescript": "^5.3.3",
    "@types/node": "^20.10.6",
    "@types/uuid": "^9.0.7",
    
    "jest": "^29.7.0",
    "@types/jest": "^29.5.11",
    "ts-jest": "^29.1.1",
    
    "eslint": "^8.56.0",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0"
  }
}
```

---

## üîß FileDetection FunctionÔºàJavaScriptÁâàÔºâ

### „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊßãÈÄ†

```mermaid
graph TD
    A[Event Grid Trigger] --> B[index.ts]
    B --> C[handler.ts]
    
    C --> D[BlobValidator]
    C --> E[FileCompletenessChecker]
    C --> F[JobInitializer]
    
    D --> G[shared/validators]
    E --> H[shared/azure-client]
    F --> I[shared/job-models]
    
    H --> J[BlobServiceClient]
    H --> K[TableClient]
    
    C --> L[shared/logger]
    L --> M[Application Insights]
    
    style B fill:#90EE90
    style C fill:#87CEEB
    style D fill:#FFB6C1
    style E fill:#FFB6C1
    style F fill:#FFB6C1
```

### ÂûãÂÆöÁæ©„Å®„ÇØ„É©„ÇπË®≠Ë®à

#### types.ts
```typescript
import { EventGridEvent } from '@azure/eventgrid';

export interface BlobCreatedEventData {
  api: string;
  clientRequestId: string;
  requestId: string;
  eTag: string;
  contentType: string;
  contentLength: number;
  blobType: string;
  url: string;
  sequencer: string;
  storageDiagnostics: {
    batchId: string;
  };
}

export interface FileDetectionResult {
  status: 'success' | 'waiting' | 'error';
  jobId?: string;
  directory?: string;
  message?: string;
}

export interface FileCheckResult {
  isComplete: boolean;
  foundFiles: string[];
  missingFiles: string[];
}
```

#### index.ts
```typescript
import { app, EventGridEvent, InvocationContext } from '@azure/functions';
import { FileDetectionHandler } from './handler';
import { StructuredLogger } from '../../shared/utils/logger';

const logger = new StructuredLogger('FileDetection');

app.eventGrid('fileDetection', {
  handler: async (event: EventGridEvent, context: InvocationContext) => {
    logger.info('Event Grid trigger started', {
      eventId: event.id,
      eventType: event.eventType,
      invocationId: context.invocationId
    });

    try {
      const handler = new FileDetectionHandler();
      const result = await handler.handle(event);

      logger.info('File detection completed', {
        result,
        invocationId: context.invocationId
      });

      return result;
    } catch (error) {
      logger.error('File detection failed', {
        error: error instanceof Error ? error.message : String(error),
        invocationId: context.invocationId
      }, error);

      throw error;
    }
  }
});
```

#### handler.ts
```typescript
import { EventGridEvent } from '@azure/eventgrid';
import { AzureBlobClient, AzureTableClient } from '../../shared/utils/azure-client';
import { StructuredLogger } from '../../shared/utils/logger';
import { FileValidator } from '../../shared/utils/validators';
import { Job, JobStatus } from '../../shared/models/job-models';
import { REQUIRED_FILES } from '../../shared/constants';
import axios from 'axios';
import { v4 as uuidv4 } from 'uuid';
import { format } from 'date-fns';
import type { 
  BlobCreatedEventData, 
  FileDetectionResult,
  FileCheckResult 
} from './types';

export class FileDetectionHandler {
  private blobClient: AzureBlobClient;
  private tableClient: AzureTableClient;
  private logger: StructuredLogger;
  private validator: FileValidator;

  constructor() {
    this.blobClient = new AzureBlobClient();
    this.tableClient = new AzureTableClient();
    this.logger = new StructuredLogger('FileDetectionHandler');
    this.validator = new FileValidator();
  }

  async handle(event: EventGridEvent): Promise<FileDetectionResult> {
    try {
      // „Ç§„Éô„É≥„Éà„Éá„Éº„ÇøËß£Êûê
      const eventData = event.data as BlobCreatedEventData;
      const blobUrl = eventData.url;
      const directory = this.extractDirectory(blobUrl);

      this.logger.info('File detection started', {
        directory,
        blobUrl,
        eventId: event.id
      });

      // „Éï„Ç°„Ç§„É´ÂÆåÂÖ®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
      const checkResult = await this.checkFileCompleteness(directory);

      if (!checkResult.isComplete) {
        this.logger.warning('Files not complete yet', {
          directory,
          foundFiles: checkResult.foundFiles,
          missingFiles: checkResult.missingFiles
        });

        return { 
          status: 'waiting', 
          directory,
          message: `Waiting for files: ${checkResult.missingFiles.join(', ')}`
        };
      }

      // „Ç∏„Éß„ÉñÂàùÊúüÂåñ
      const job = await this.initializeJob(directory, checkResult.foundFiles);

      // Â§âÊèõFunction„Éà„É™„Ç¨„Éº
      await this.triggerTransform(job);

      this.logger.info('File detection completed', {
        jobId: job.jobId,
        fileCount: checkResult.foundFiles.length
      });

      return { 
        status: 'success', 
        jobId: job.jobId,
        directory
      };

    } catch (error) {
      this.logger.error('File detection failed', {
        error: error instanceof Error ? error.message : String(error)
      }, error);

      throw error;
    }
  }

  private extractDirectory(blobUrl: string): string {
    /**
     * Blob URL„Åã„Çâ„Éá„Ç£„É¨„ÇØ„Éà„É™„Éë„ÇπÊäΩÂá∫
     * ‰æã: .../sds-csv-input/20251027/school.csv ‚Üí 20251027
     */
    const urlParts = blobUrl.split('/');
    const containerIndex = urlParts.findIndex(part => part === 'sds-csv-input');
    
    if (containerIndex === -1 || containerIndex === urlParts.length - 1) {
      throw new Error('Invalid blob URL format');
    }

    return urlParts[containerIndex + 1];
  }

  private async checkFileCompleteness(directory: string): Promise<FileCheckResult> {
    /**
     * „Éï„Ç°„Ç§„É´ÂÆåÂÖ®ÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
     * 
     * ÂøÖÈ†à„Éï„Ç°„Ç§„É´Ôºà„É¶„Éº„Ç∂„ÉºÁÆ°ÁêÜ„ÅÆ„ÅøÔºâ:
     * - school.csv
     * - student.csv
     * - teacher.csv
     * 
     * „Ç™„Éó„Ç∑„Éß„É≥„Éï„Ç°„Ç§„É´Ôºà„ÇØ„É©„ÇπÁÆ°ÁêÜÔºâ:
     * - section.csv
     * - studentenrollment.csv
     * - teacherroster.csv
     */
    const prefix = `sds-csv-input/${directory}/`;
    const blobs = await this.blobClient.listBlobs('sds-csv-input', prefix);

    const fileNames = blobs.map(blob => blob.name.split('/').pop()!);

    // ÂøÖÈ†à„Éï„Ç°„Ç§„É´„ÉÅ„Çß„ÉÉ„ÇØ
    const requiredFiles = new Set(['school.csv', 'student.csv', 'teacher.csv']);
    const foundFiles = fileNames.filter(name => requiredFiles.has(name));
    const missingFiles = Array.from(requiredFiles).filter(name => !fileNames.includes(name));

    return {
      isComplete: missingFiles.length === 0,
      foundFiles: fileNames,
      missingFiles
    };
  }

  private async initializeJob(directory: string, files: string[]): Promise<Job> {
    /**
     * „Ç∏„Éß„ÉñÂàùÊúüÂåñ
     */
    const now = new Date();
    const jobId = `job-${format(now, 'yyyyMMdd-HHmmss')}-${uuidv4().substring(0, 8)}`;

    const job: Job = {
      partitionKey: format(now, 'yyyy-MM'),
      rowKey: jobId,
      jobId,
      status: JobStatus.Processing,
      startTime: now.toISOString(),
      inputDirectory: `sds-csv-input/${directory}/`,
      inputFiles: files,
      userId: 'system', // ÂÆüÈöõ„ÅØAzure AD„Åã„ÇâÂèñÂæó
      version: 'javascript'
    };

    // Table Storage„Å´‰øùÂ≠ò
    await this.tableClient.insertEntity('JobHistory', job);

    return job;
  }

  private async triggerTransform(job: Job): Promise<void> {
    /**
     * „Éá„Éº„ÇøÂ§âÊèõFunction„Çí„Éà„É™„Ç¨„Éº
     */
    const transformUrl = process.env.TRANSFORM_FUNCTION_URL;
    
    if (!transformUrl) {
      throw new Error('TRANSFORM_FUNCTION_URL not configured');
    }

    const payload = {
      jobId: job.jobId,
      inputDirectory: job.inputDirectory,
      files: job.inputFiles
    };

    try {
      const response = await axios.post(transformUrl, payload, {
        headers: { 'Content-Type': 'application/json' },
        timeout: 30000
      });

      this.logger.info('Transform function triggered', {
        jobId: job.jobId,
        statusCode: response.status
      });
    } catch (error) {
      this.logger.error('Failed to trigger transform function', {
        jobId: job.jobId,
        error: error instanceof Error ? error.message : String(error)
      }, error);

      throw error;
    }
  }
}
```

---

## üîÑ DataTransform FunctionÔºàJavaScriptÁâàÔºâ

### „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊßãÈÄ†

```mermaid
graph TD
    A[HTTP Trigger] --> B[index.ts]
    B --> C[handler.ts]
    
    C --> D[CSVReader]
    C --> E[DataValidator]
    C --> F[DataTransformer]
    C --> G[CSVWriter]
    
    D --> H[csv-parse]
    E --> I[zod schemas]
    F --> J[mapper.ts]
    
    J --> K[SDSToOneRosterMapper]
    K --> L[GUIDGenerator]
    K --> M[FieldMapper]
    
    G --> N[shared/azure-client]
    N --> O[Blob Storage]
    
    C --> P[shared/logger]
    
    style B fill:#90EE90
    style C fill:#87CEEB
    style F fill:#FFD700
```

### ÂûãÂÆöÁæ©„Å®„ÇØ„É©„ÇπË®≠Ë®à

#### transformer.ts
```typescript
import { parse } from 'csv-parse/sync';
import { stringify } from 'csv-stringify/sync';
import { StructuredLogger } from '../../shared/utils/logger';
import { SDSSchool, SDSStudent, SDSTeacher } from '../../shared/models/sds-models';
import { 
  OneRosterOrg, 
  OneRosterUser,
  OneRosterCourse,
  OneRosterClass,
  OneRosterEnrollment
} from '../../shared/models/oneroster-models';
import { SDSToOneRosterMapper } from './mapper';

export class DataTransformer {
  private logger: StructuredLogger;
  private mapper: SDSToOneRosterMapper;

  constructor() {
    this.logger = new StructuredLogger('DataTransformer');
    this.mapper = new SDSToOneRosterMapper();
  }

  async transformSchools(csvContent: string): Promise<string> {
    /**
     * school.csv ‚Üí orgs.csv Â§âÊèõ
     * 
     * SDS„Éï„Ç£„Éº„É´„Éâ:
     * - School SIS ID
     * - Name
     * - School Number
     * - School NCES_ID (optional)
     * - State ID (optional)
     * 
     * OneRoster„Éï„Ç£„Éº„É´„Éâ:
     * - sourcedId (GUID)
     * - status (active)
     * - dateLastModified
     * - name
     * - type (school)
     * - identifier (School SIS ID)
     */
    this.logger.info('Transforming schools');

    // CSVËß£Êûê
    const records = parse(csvContent, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    }) as SDSSchool[];

    this.logger.info(`Parsing ${records.length} schools`);

    // Â§âÊèõ
    const orgs: OneRosterOrg[] = records.map(record => 
      this.mapper.mapSchoolToOrg(record)
    );

    // CSVÁîüÊàê
    const outputCsv = stringify(orgs, {
      header: true,
      columns: [
        'sourcedId',
        'status',
        'dateLastModified',
        'name',
        'type',
        'identifier',
        'parentSourcedId'
      ]
    });

    return outputCsv;
  }

  async transformUsers(
    studentsCsv: string,
    teachersCsv: string
  ): Promise<string> {
    /**
     * student.csv + teacher.csv ‚Üí users.csv Â§âÊèõ
     */
    this.logger.info('Transforming users');

    // Â≠¶ÁîüËß£Êûê
    const students = parse(studentsCsv, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    }) as SDSStudent[];

    // ÊïôÂì°Ëß£Êûê
    const teachers = parse(teachersCsv, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    }) as SDSTeacher[];

    this.logger.info(
      `Parsing ${students.length} students and ${teachers.length} teachers`
    );

    const users: OneRosterUser[] = [];

    // Â≠¶ÁîüÂ§âÊèõ
    students.forEach(student => {
      users.push(this.mapper.mapStudentToUser(student));
    });

    // ÊïôÂì°Â§âÊèõ
    teachers.forEach(teacher => {
      users.push(this.mapper.mapTeacherToUser(teacher));
    });

    // CSVÁîüÊàê
    const outputCsv = stringify(users, {
      header: true,
      columns: [
        'sourcedId',
        'status',
        'dateLastModified',
        'enabledUser',
        'username',
        'userIds',
        'givenName',
        'familyName',
        'middleName',
        'role',
        'identifier',
        'email',
        'sms',
        'phone',
        'orgs',
        'grades'
      ]
    });

    return outputCsv;
  }

  async transformCourses(sectionsCsv: string): Promise<string> {
    /**
     * section.csv ‚Üí courses.csv Â§âÊèõ
     */
    this.logger.info('Transforming courses');

    const sections = parse(sectionsCsv, {
      columns: true,
      skip_empty_lines: true,
      trim: true
    });

    // „Ç≥„Éº„ÇπÊäΩÂá∫ÔºàÈáçË§áÈô§ÂéªÔºâ
    const courseMap = new Map<string, OneRosterCourse>();

    sections.forEach((section: any) => {
      const courseId = section['Course SIS ID'];
      if (!courseMap.has(courseId)) {
        courseMap.set(
          courseId,
          this.mapper.mapSectionToCourse(section)
        );
      }
    });

    const courses = Array.from(courseMap.values());

    const outputCsv = stringify(courses, {
      header: true,
      columns: [
        'sourcedId',
        'status',
        'dateLastModified',
        'schoolYearSourcedId',
        'title',
        'courseCode',
        'grades',
        'subjects',
        'orgSourcedId'
      ]
    });

    return outputCsv;
  }
}
```

#### mapper.ts
```typescript
import { v5 as uuidv5 } from 'uuid';
import { format } from 'date-fns';
import { SDSSchool, SDSStudent, SDSTeacher } from '../../shared/models/sds-models';
import { OneRosterOrg, OneRosterUser } from '../../shared/models/oneroster-models';

export class SDSToOneRosterMapper {
  private guidCache: Map<string, string>;
  private namespace: string;

  constructor() {
    this.guidCache = new Map();
    // OneRosterÂ∞ÇÁî®ÂêçÂâçÁ©∫ÈñìUUID
    this.namespace = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
  }

  mapSchoolToOrg(sdsSchool: SDSSchool): OneRosterOrg {
    /**
     * school.csv ‚Üí orgs.csv „Éû„ÉÉ„Éî„É≥„Ç∞
     * 
     * Â§âÊèõ„É´„Éº„É´:
     * 1. sourcedId: SDS ID „Åã„ÇâGUIDÁîüÊàêÔºàÊ±∫ÂÆöÁöÑÔºâ
     * 2. name: Name „Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
     * 3. type: Âõ∫ÂÆöÂÄ§ "school"
     * 4. identifier: School SIS ID
     */
    const sdsId = String(sdsSchool['School SIS ID']);
    const sourcedId = this.generateDeterministicGuid('school', sdsId);

    const org: OneRosterOrg = {
      sourcedId,
      status: 'active',
      dateLastModified: new Date().toISOString(),
      name: sdsSchool.Name,
      type: 'school',
      identifier: sdsId,
      parentSourcedId: undefined,
      metadata: {
        schoolNumber: sdsSchool['School Number'],
        ncesId: sdsSchool['School NCES_ID'],
        stateId: sdsSchool['State ID']
      }
    };

    return org;
  }

  mapStudentToUser(sdsStudent: SDSStudent): OneRosterUser {
    /**
     * student.csv ‚Üí users.csv „Éû„ÉÉ„Éî„É≥„Ç∞
     */
    const sdsId = String(sdsStudent['SIS ID']);
    const sourcedId = this.generateDeterministicGuid('student', sdsId);

    // „É°„Éº„É´„Ç¢„Éâ„É¨„ÇπÁîüÊàêÔºàÂ≠òÂú®„Åó„Å™„ÅÑÂ†¥ÂêàÔºâ
    const email = sdsStudent.Username 
      ? `${sdsStudent.Username}@example.edu` 
      : `${sdsId}@example.edu`;

    const user: OneRosterUser = {
      sourcedId,
      status: 'active',
      dateLastModified: new Date().toISOString(),
      enabledUser: true,
      username: sdsStudent.Username || sdsId,
      userIds: JSON.stringify([{
        type: 'SIS',
        identifier: sdsId
      }]),
      givenName: sdsStudent['First Name'] || '',
      familyName: sdsStudent['Last Name'] || '',
      middleName: sdsStudent['Middle Name'],
      role: 'student',
      identifier: sdsId,
      email,
      sms: sdsStudent.Phone,
      phone: sdsStudent.Phone,
      orgs: this.getOrgGuid(sdsStudent['School SIS ID']),
      grades: sdsStudent.Grade ? JSON.stringify([sdsStudent.Grade]) : undefined
    };

    return user;
  }

  mapTeacherToUser(sdsTeacher: SDSTeacher): OneRosterUser {
    /**
     * teacher.csv ‚Üí users.csv „Éû„ÉÉ„Éî„É≥„Ç∞
     */
    const sdsId = String(sdsTeacher['SIS ID']);
    const sourcedId = this.generateDeterministicGuid('teacher', sdsId);

    const email = sdsTeacher.Username 
      ? `${sdsTeacher.Username}@example.edu` 
      : `${sdsId}@example.edu`;

    const user: OneRosterUser = {
      sourcedId,
      status: 'active',
      dateLastModified: new Date().toISOString(),
      enabledUser: true,
      username: sdsTeacher.Username || sdsId,
      userIds: JSON.stringify([{
        type: 'SIS',
        identifier: sdsId
      }]),
      givenName: sdsTeacher['First Name'] || '',
      familyName: sdsTeacher['Last Name'] || '',
      middleName: sdsTeacher['Middle Name'],
      role: 'teacher',
      identifier: sdsId,
      email,
      sms: sdsTeacher.Phone,
      phone: sdsTeacher.Phone,
      orgs: this.getOrgGuid(sdsTeacher['School SIS ID']),
      grades: undefined
    };

    return user;
  }

  private generateDeterministicGuid(entityType: string, entityId: string): string {
    /**
     * Ê±∫ÂÆöÁöÑGUIDÁîüÊàê
     * Âêå„ÅòÂÖ•Âäõ„Å™„ÇâÂ∏∏„Å´Âêå„ÅòGUID„ÇíËøî„ÅôÔºàUUID v5‰ΩøÁî®Ôºâ
     * 
     * @param entityType - „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£„Çø„Ç§„ÉóÔºàschool, student, teacherÁ≠âÔºâ
     * @param entityId - „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£IDÔºàSDS IDÔºâ
     * @returns UUIDÂΩ¢Âºè„ÅÆÊñáÂ≠óÂàó
     */
    const cacheKey = `${entityType}:${entityId}`;

    if (this.guidCache.has(cacheKey)) {
      return this.guidCache.get(cacheKey)!;
    }

    // entity_type + entity_id „Åã„ÇâÊ±∫ÂÆöÁöÑ„Å´GUIDÁîüÊàê
    const guid = uuidv5(cacheKey, this.namespace);

    this.guidCache.set(cacheKey, guid);
    return guid;
  }

  private getOrgGuid(schoolSisId?: string): string | undefined {
    /**
     * ÁµÑÁπîGUID„ÇíÂèñÂæóÔºàÂ≠¶Ê†°ID„Åã„ÇâÔºâ
     */
    if (!schoolSisId) {
      return undefined;
    }

    return this.generateDeterministicGuid('school', String(schoolSisId));
  }
}
```

---

## üì§ FileUploader FunctionÔºàJavaScriptÁâàÔºâ

### „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊßãÈÄ†

```mermaid
graph TD
    A[HTTP Trigger] --> B[index.ts]
    B --> C[handler.ts]
    
    C --> D[MetadataBuilder]
    C --> E[CSVUploadAPIClient]
    C --> F[RetryHandler]
    
    D --> G[metadata-builder.ts]
    G --> H[crypto SHA-256]
    
    E --> I[client.ts]
    I --> J[axios]
    I --> K[DefaultAzureCredential]
    
    F --> L[exponential_backoff]
    
    C --> M[shared/azure-client]
    M --> N[Blob Storage]
    M --> O[Table Storage]
    M --> P[Key Vault Client]
    
    style B fill:#90EE90
    style C fill:#87CEEB
    style E fill:#FF6347
```

### „ÇØ„É©„ÇπË®≠Ë®à

#### metadata-builder.ts
```typescript
import * as crypto from 'crypto';
import { StructuredLogger } from '../../shared/utils/logger';
import { AzureBlobClient } from '../../shared/utils/azure-client';

interface MetadataJSON {
  source: string;
  version: string;
  uploadedAt: string;
  recordCounts: Record<string, number>;
  checksums: Record<string, string>;
}

export class MetadataBuilder {
  private blobClient: AzureBlobClient;
  private logger: StructuredLogger;

  constructor() {
    this.blobClient = new AzureBlobClient();
    this.logger = new StructuredLogger('MetadataBuilder');
  }

  async buildMetadata(
    outputDirectory: string,
    fileList: string[]
  ): Promise<MetadataJSON> {
    /**
     * metadata.jsonÁîüÊàê
     * 
     * @param outputDirectory - Âá∫Âäõ„Éá„Ç£„É¨„ÇØ„Éà„É™„Éë„Çπ
     * @param fileList - CSV„Éï„Ç°„Ç§„É´Âêç„É™„Çπ„Éà
     * @returns „É°„Çø„Éá„Éº„Çø„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
     */
    this.logger.info('Building metadata', {
      directory: outputDirectory,
      fileCount: fileList.length
    });

    const checksums: Record<string, string> = {};
    const recordCounts: Record<string, number> = {};

    for (const filename of fileList) {
      const blobPath = `${outputDirectory}/${filename}`;

      // „Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„Åø
      const content = await this.blobClient.downloadBlob(
        'oneroster-output',
        blobPath
      );

      // SHA-256„ÉÅ„Çß„ÉÉ„ÇØ„Çµ„É†Ë®àÁÆó
      const hash = crypto.createHash('sha256');
      hash.update(content);
      const checksum = hash.digest('hex');
      checksums[filename] = checksum;

      // „É¨„Ç≥„Éº„ÉâÊï∞„Ç´„Ç¶„É≥„ÉàÔºà„Éò„ÉÉ„ÉÄ„ÉºÈô§„ÅèÔºâ
      const lines = content.trim().split('\n');
      const recordCount = Math.max(0, lines.length - 1); // „Éò„ÉÉ„ÉÄ„ÉºË°å„ÇíÈô§„Åè
      recordCounts[filename] = recordCount;

      this.logger.debug(`File processed: ${filename}`, {
        checksum: checksum.substring(0, 16) + '...',
        records: recordCount
      });
    }

    // „É°„Çø„Éá„Éº„ÇøÊßãÁØâ
    const metadata: MetadataJSON = {
      source: 'SDS2Roster',
      version: '1.0.0',
      uploadedAt: new Date().toISOString(),
      recordCounts,
      checksums
    };

    const totalRecords = Object.values(recordCounts).reduce((a, b) => a + b, 0);

    this.logger.info('Metadata built successfully', {
      totalRecords,
      totalFiles: fileList.length
    });

    return metadata;
  }
}
```

#### client.ts
```typescript
import axios, { AxiosInstance } from 'axios';
import FormData from 'form-data';
import { DefaultAzureCredential } from '@azure/identity';
import { SecretClient } from '@azure/keyvault-secrets';
import { StructuredLogger } from '../../shared/utils/logger';

interface UploadResponse {
  uploadId: string;
  status: string;
  message: string;
  receivedAt: string;
}

interface StatusResponse {
  uploadId: string;
  status: 'accepted' | 'processing' | 'completed' | 'failed' | 'partial_success';
  receivedAt: string;
  processedAt?: string;
  completedAt?: string;
  totalFiles: number;
  processedFiles: number;
  failedFiles: number;
  recordCounts?: Record<string, number>;
  errors?: Array<{ file: string; error: string }>;
}

interface TokenCacheEntry {
  accessToken: string;
  expiresAt: Date;
}

export class CSVUploadAPIClient {
  private kvClient: SecretClient;
  private credential: DefaultAzureCredential;
  private logger: StructuredLogger;
  private axiosInstance: AxiosInstance;
  private tokenCache?: TokenCacheEntry;

  constructor() {
    const keyVaultUrl = process.env.KEY_VAULT_URL;
    if (!keyVaultUrl) {
      throw new Error('KEY_VAULT_URL not configured');
    }

    this.credential = new DefaultAzureCredential();
    this.kvClient = new SecretClient(keyVaultUrl, this.credential);
    this.logger = new StructuredLogger('CSVUploadAPIClient');

    this.axiosInstance = axios.create({
      timeout: 60000, // 60ÁßíÔºà„Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁî®Ôºâ
    });
  }

  async uploadCSVFiles(
    files: Record<string, Buffer>,
    metadata: Record<string, any>
  ): Promise<UploadResponse> {
    /**
     * CSV„Éï„Ç°„Ç§„É´‰∏ÄÊã¨„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
     * 
     * @param files - „Éï„Ç°„Ç§„É´Âêç -> „Éï„Ç°„Ç§„É´ÂÜÖÂÆπ„ÅÆ„Éû„ÉÉ„Éó
     * @param metadata - „É°„Çø„Éá„Éº„Çø„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
     * @returns API„É¨„Çπ„Éù„É≥„ÇπÔºàuploadIdÂê´„ÇÄÔºâ
     */
    this.logger.info('Starting CSV file upload', {
      fileCount: Object.keys(files).length
    });

    // API„Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà„Å®„Ç≠„ÉºÂèñÂæó
    const apiEndpoint = await this.getSecret('upload-api-endpoint');
    const apiKey = await this.getSecret('upload-api-key');

    // Azure AD„Éà„Éº„ÇØ„É≥ÂèñÂæó
    const accessToken = await this.getAccessToken();

    // FormDataÊßãÁØâ
    const formData = new FormData();

    // „É°„Çø„Éá„Éº„ÇøËøΩÂä†
    formData.append(
      'metadata',
      JSON.stringify(metadata),
      {
        filename: 'metadata.json',
        contentType: 'application/json'
      }
    );

    // CSV„Éï„Ç°„Ç§„É´ËøΩÂä†
    for (const [filename, content] of Object.entries(files)) {
      formData.append('files', content, {
        filename,
        contentType: 'text/csv'
      });
    }

    try {
      const response = await this.axiosInstance.post<UploadResponse>(
        `${apiEndpoint}/api/v1/upload`,
        formData,
        {
          headers: {
            ...formData.getHeaders(),
            'Authorization': `Bearer ${accessToken}`,
            'X-API-Key': apiKey
          },
          maxBodyLength: 100 * 1024 * 1024, // 100MB
          maxContentLength: 100 * 1024 * 1024
        }
      );

      this.logger.info('CSV files uploaded successfully', {
        uploadId: response.data.uploadId,
        status: response.data.status
      });

      return response.data;
    } catch (error: any) {
      this.logger.error('CSV upload failed', {
        error: error.message,
        status: error.response?.status,
        data: error.response?.data
      });
      throw error;
    }
  }

  async getUploadStatus(uploadId: string): Promise<StatusResponse> {
    /**
     * „Ç¢„ÉÉ„Éó„É≠„Éº„Éâ„Çπ„ÉÜ„Éº„Çø„ÇπÁ¢∫Ë™ç
     * 
     * @param uploadId - „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâID
     * @returns „Çπ„ÉÜ„Éº„Çø„ÇπÊÉÖÂ†±
     */
    const apiEndpoint = await this.getSecret('upload-api-endpoint');
    const apiKey = await this.getSecret('upload-api-key');
    const accessToken = await this.getAccessToken();

    try {
      const response = await this.axiosInstance.get<StatusResponse>(
        `${apiEndpoint}/api/v1/upload/${uploadId}`,
        {
          headers: {
            'Authorization': `Bearer ${accessToken}`,
            'X-API-Key': apiKey
          }
        }
      );

      return response.data;
    } catch (error: any) {
      this.logger.error('Failed to get upload status', {
        uploadId,
        error: error.message
      });
      throw error;
    }
  }

  private async getAccessToken(forceRefresh: boolean = false): Promise<string> {
    /**
     * Azure AD„Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥ÂèñÂæó
     */
    if (!forceRefresh && this.isTokenValid()) {
      return this.tokenCache!.accessToken;
    }

    this.logger.info('Requesting new Azure AD access token');

    const tokenResponse = await this.credential.getToken(
      'https://management.azure.com/.default'
    );

    if (!tokenResponse) {
      throw new Error('Failed to obtain access token');
    }

    // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠ò
    this.tokenCache = {
      accessToken: tokenResponse.token,
      expiresAt: new Date(tokenResponse.expiresOnTimestamp)
    };

    this.logger.info('Access token obtained successfully');
    return tokenResponse.token;
  }

  private isTokenValid(): boolean {
    /**
     * „Éà„Éº„ÇØ„É≥ÊúâÂäπÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
     */
    if (!this.tokenCache) {
      return false;
    }

    // 5ÂàÜ„ÅÆ„Éê„ÉÉ„Éï„Ç°„ÇíÊåÅ„Åü„Åõ„Çã
    const bufferTime = 5 * 60 * 1000;
    return Date.now() < (this.tokenCache.expiresAt.getTime() - bufferTime);
  }

  private async getSecret(secretName: string): Promise<string> {
    /**
     * Key Vault„Åã„Çâ„Ç∑„Éº„ÇØ„É¨„ÉÉ„ÉàÂèñÂæó
     */
    const secret = await this.kvClient.getSecret(secretName);

    if (!secret.value) {
      throw new Error(`Secret ${secretName} has no value`);
    }

    return secret.value;
  }
}
```

#### handler.ts
```typescript
import { AzureBlobClient, AzureTableClient } from '../../shared/utils/azure-client';
import { StructuredLogger } from '../../shared/utils/logger';
import { MetadataBuilder } from './metadata-builder';
import { CSVUploadAPIClient } from './client';

interface FileUploaderInput {
  jobId: string;
  outputDirectory: string;
}

export class FileUploaderHandler {
  private blobClient: AzureBlobClient;
  private tableClient: AzureTableClient;
  private metadataBuilder: MetadataBuilder;
  private uploadClient: CSVUploadAPIClient;
  private logger: StructuredLogger;

  constructor() {
    this.blobClient = new AzureBlobClient();
    this.tableClient = new AzureTableClient();
    this.metadataBuilder = new MetadataBuilder();
    this.uploadClient = new CSVUploadAPIClient();
    this.logger = new StructuredLogger('FileUploaderHandler');
  }

  async execute(input: FileUploaderInput): Promise<void> {
    /**
     * „Éï„Ç°„Ç§„É´„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂá¶ÁêÜ
     * 
     * @param input - ÂÖ•Âäõ„Éë„É©„É°„Éº„Çø
     */
    const { jobId, outputDirectory } = input;

    this.logger.info('Starting file upload process', {
      jobId,
      outputDirectory
    });

    try {
      // „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞: Uploading
      await this.updateJobStatus(jobId, 'Uploading');

      // OneRoster CSV„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
      const csvFiles = await this.getCSVFiles(outputDirectory);

      // metadata.jsonÁîüÊàê
      const metadata = await this.metadataBuilder.buildMetadata(
        outputDirectory,
        csvFiles
      );

      // „Éï„Ç°„Ç§„É´ÂÜÖÂÆπË™≠„ÅøËæº„Åø
      const filesContent: Record<string, Buffer> = {};
      for (const filename of csvFiles) {
        const blobPath = `${outputDirectory}/${filename}`;
        const content = await this.blobClient.downloadBlob(
          'oneroster-output',
          blobPath
        );
        filesContent[filename] = Buffer.from(content, 'utf-8');
      }

      // CSV Upload API„Å∏„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ
      const uploadResponse = await this.uploadClient.uploadCSVFiles(
        filesContent,
        metadata
      );

      this.logger.info('Upload initiated', {
        uploadId: uploadResponse.uploadId,
        status: uploadResponse.status
      });

      // „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁµêÊûú„ÇíË®òÈå≤
      await this.recordUploadResult(jobId, uploadResponse);

      // „Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞: Completed
      await this.updateJobStatus(jobId, 'Completed', {
        uploadId: uploadResponse.uploadId,
        uploadStatus: uploadResponse.status
      });

      this.logger.info('File upload process completed', {
        jobId,
        uploadId: uploadResponse.uploadId
      });

    } catch (error: any) {
      this.logger.error('File upload process failed', {
        jobId,
        error: error.message,
        stack: error.stack
      });

      await this.updateJobStatus(jobId, 'Failed', {
        error: error.message
      });

      throw error;
    }
  }

  private async getCSVFiles(directory: string): Promise<string[]> {
    /**
     * OneRoster CSV„Éï„Ç°„Ç§„É´‰∏ÄË¶ßÂèñÂæó
     */
    const allFiles = await this.blobClient.listBlobs(
      'oneroster-output',
      directory
    );

    // OneRosterÊ®ôÊ∫ñ„Éï„Ç°„Ç§„É´„ÅÆ„Åø„Éï„Ç£„É´„Çø
    const csvFiles = allFiles.filter(f =>
      f.endsWith('.csv') &&
      [
        'orgs.csv',
        'users.csv',
        'courses.csv',
        'classes.csv',
        'enrollments.csv',
        'academicSessions.csv',
        'demographics.csv',
        'categories.csv',
        'resources.csv'
      ].some(name => f.includes(name))
    );

    this.logger.info(`Found ${csvFiles.length} OneRoster CSV files`);

    return csvFiles.map(f => f.split('/').pop()!);
  }

  private async recordUploadResult(
    jobId: string,
    uploadResponse: any
  ): Promise<void> {
    /**
     * „Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÁµêÊûú„ÇíË®òÈå≤
     */
    await this.tableClient.upsertEntity('JobHistory', {
      PartitionKey: jobId.substring(0, 7), // YYYY-MM
      RowKey: jobId,
      uploadId: uploadResponse.uploadId,
      uploadStatus: uploadResponse.status,
      uploadedAt: uploadResponse.receivedAt,
      lastUpdated: new Date().toISOString()
    });
  }

  private async updateJobStatus(
    jobId: string,
    status: string,
    additionalData?: Record<string, any>
  ): Promise<void> {
    /**
     * „Ç∏„Éß„Éñ„Çπ„ÉÜ„Éº„Çø„ÇπÊõ¥Êñ∞
     */
    const updateData: Record<string, any> = {
      PartitionKey: jobId.substring(0, 7),
      RowKey: jobId,
      status,
      lastUpdated: new Date().toISOString(),
      ...additionalData
    };

    if (status === 'Completed') {
      updateData.endTime = new Date().toISOString();
    }

    await this.tableClient.upsertEntity('JobHistory', updateData);

    this.logger.info(`Job status updated: ${status}`, { jobId });
  }
}
```

---

    this.logger.info(`Posting ${entityType}`, {
      count: data.length,
      endpoint
    });

    // „É™„Éà„É©„Ç§„É≠„Ç∏„ÉÉ„ÇØ‰ªò„ÅçÈÄÅ‰ø°
    const response = await this.postWithRetry(url, data, token);

    this.logger.info(`${entityType} posted successfully`, {
      count: data.length,
      statusCode: response.status
    });

    return response.data;
  }

  private async postWithRetry(
    url: string,
    data: any[],
    token: string,
    maxRetries: number = 3
  ): Promise<AxiosResponse> {
    /**
     * „É™„Éà„É©„Ç§„É≠„Ç∏„ÉÉ„ÇØ‰ªò„ÅçPOST
     * 
     * Exponential Backoff:
     * - 1ÂõûÁõÆ: Âç≥Â∫ß
     * - 2ÂõûÁõÆ: 2ÁßíÂæÖÊ©ü
     * - 3ÂõûÁõÆ: 4ÁßíÂæÖÊ©ü
     * - 4ÂõûÁõÆ: 8ÁßíÂæÖÊ©ü
     */
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const response = await this.axiosInstance.post(url, data, {
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });

        // ÊàêÂäü (2xx)
        return response;

      } catch (error) {
        if (!axios.isAxiosError(error)) {
          throw error;
        }

        const statusCode = error.response?.status;

        // 4xx „Ç®„É©„ÉºÔºà„É™„Éà„É©„Ç§„Åó„Å™„ÅÑÔºâ
        if (statusCode && statusCode >= 400 && statusCode < 500) {
          this.logger.error('Client error, no retry', {
            statusCode,
            response: error.response?.data
          });
          throw error;
        }

        // 5xx „Ç®„É©„Éº„Åæ„Åü„ÅØ„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„Ç®„É©„ÉºÔºà„É™„Éà„É©„Ç§Ôºâ
        if (attempt < maxRetries) {
          const waitTime = Math.pow(2, attempt) * 1000;
          this.logger.warning(`Request failed, retry in ${waitTime}ms`, {
            attempt: attempt + 1,
            statusCode,
            error: error.message
          });

          await this.sleep(waitTime);
          continue;
        }

        // ÊúÄÁµÇË©¶Ë°å„ÅßÂ§±Êïó
        this.logger.error('Request failed after all retries', {
          attempts: maxRetries + 1,
          error: error.message
        });
        throw error;
      }
    }

    throw new Error('Unexpected error in retry logic');
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

---

## üìä JobMonitor FunctionÔºàJavaScriptÁâàÔºâ

### „ÇØ„É©„ÇπË®≠Ë®à

#### reporter.ts
```typescript
import { AzureTableClient, AzureBlobClient } from '../../shared/utils/azure-client';
import { StructuredLogger } from '../../shared/utils/logger';
import { Job, JobStatus } from '../../shared/models/job-models';
import { stringify } from 'csv-stringify/sync';
import { format, startOfDay, endOfDay } from 'date-fns';

interface DailyReport {
  date: string;
  totalJobs: number;
  completed: number;
  failed: number;
  processing: number;
  successRate: number;
  avgDurationMinutes: number;
  totalRecords: number;
  pythonJobs: number;
  javascriptJobs: number;
}

export class JobReporter {
  private tableClient: AzureTableClient;
  private blobClient: AzureBlobClient;
  private logger: StructuredLogger;

  constructor() {
    this.tableClient = new AzureTableClient();
    this.blobClient = new AzureBlobClient();
    this.logger = new StructuredLogger('JobReporter');
  }

  async generateDailyReport(targetDate: Date): Promise<DailyReport> {
    /**
     * Êó•Ê¨°„É¨„Éù„Éº„ÉàÁîüÊàê
     * 
     * @param targetDate - ÂØæË±°Êó•‰ªò
     * @returns „É¨„Éù„Éº„Éà„Éá„Éº„Çø
     */
    const partitionKey = format(targetDate, 'yyyy-MM');

    // ÂΩìÊó•„ÅÆ„Ç∏„Éß„ÉñÂèñÂæó
    const query = `PartitionKey eq '${partitionKey}'`;
    const entities = await this.tableClient.queryEntities('JobHistory', query);

    const jobs = entities.filter(entity => 
      this.isTargetDate(entity as Job, targetDate)
    ) as Job[];

    // Áµ±Ë®àË®àÁÆó
    const report: DailyReport = {
      date: format(targetDate, 'yyyy-MM-dd'),
      totalJobs: jobs.length,
      completed: jobs.filter(j => j.status === JobStatus.Completed).length,
      failed: jobs.filter(j => j.status === JobStatus.Failed).length,
      processing: jobs.filter(j => j.status === JobStatus.Processing).length,
      successRate: 0,
      avgDurationMinutes: 0,
      totalRecords: 0,
      pythonJobs: jobs.filter(j => j.version === 'python').length,
      javascriptJobs: jobs.filter(j => j.version === 'javascript').length
    };

    if (report.totalJobs > 0) {
      report.successRate = (report.completed / report.totalJobs) * 100;
    }

    // Âπ≥ÂùáÂá¶ÁêÜÊôÇÈñìË®àÁÆó
    const completedJobs = jobs.filter(j => 
      j.status === JobStatus.Completed && j.endTime
    );

    if (completedJobs.length > 0) {
      const durations = completedJobs.map(job => {
        const start = new Date(job.startTime);
        const end = new Date(job.endTime!);
        return (end.getTime() - start.getTime()) / (1000 * 60);
      });

      report.avgDurationMinutes = 
        durations.reduce((a, b) => a + b, 0) / durations.length;
    }

    // „É¨„Ç≥„Éº„ÉâÊï∞ÈõÜË®à
    for (const job of jobs) {
      if (job.recordCounts) {
        const counts = JSON.parse(job.recordCounts);
        report.totalRecords += Object.values(counts as Record<string, number>)
          .reduce((a, b) => a + b, 0);
      }
    }

    // CSV‰øùÂ≠ò
    await this.saveReportCsv(report, targetDate);

    return report;
  }

  private isTargetDate(job: Job, targetDate: Date): boolean {
    /**
     * „Ç∏„Éß„Éñ„ÅåÂØæË±°Êó•‰ªò„ÅãÂà§ÂÆö
     */
    if (!job.startTime) {
      return false;
    }

    const jobDate = new Date(job.startTime);
    const targetStart = startOfDay(targetDate);
    const targetEnd = endOfDay(targetDate);

    return jobDate >= targetStart && jobDate <= targetEnd;
  }

  private async saveReportCsv(report: DailyReport, targetDate: Date): Promise<void> {
    /**
     * „É¨„Éù„Éº„Éà„ÇíCSV„Å®„Åó„Å¶‰øùÂ≠ò
     */
    const csv = stringify([report], {
      header: true,
      columns: [
        'date',
        'totalJobs',
        'completed',
        'failed',
        'processing',
        'successRate',
        'avgDurationMinutes',
        'totalRecords',
        'pythonJobs',
        'javascriptJobs'
      ]
    });

    const blobName = `reports/daily/report-${format(targetDate, 'yyyyMMdd')}.csv`;

    await this.blobClient.uploadBlob(
      'oneroster-output',
      blobName,
      Buffer.from(csv),
      'text/csv'
    );

    this.logger.info('Daily report saved', {
      date: format(targetDate, 'yyyy-MM-dd'),
      blobName
    });
  }
}
```

---

## üß© Shared ModulesÔºàÂÖ±Êúâ„É¢„Ç∏„É•„Éº„É´Ôºâ

### models/oneroster-models.ts
```typescript
/**
 * OneRoster v1.2 „Éá„Éº„Çø„É¢„Éá„É´
 */

export interface OneRosterOrg {
  sourcedId: string;
  status: 'active' | 'tobedeleted';
  dateLastModified: string;
  name: string;
  type: 'department' | 'school' | 'district' | 'local' | 'state' | 'national';
  identifier: string;
  parentSourcedId?: string;
  metadata?: Record<string, any>;
}

export interface OneRosterUser {
  sourcedId: string;
  status: 'active' | 'tobedeleted';
  dateLastModified: string;
  enabledUser: boolean;
  username: string;
  userIds: string; // JSON array
  givenName: string;
  familyName: string;
  middleName?: string;
  role: 'student' | 'teacher' | 'administrator' | 'aide' | 'guardian' | 'parent';
  identifier: string;
  email: string;
  sms?: string;
  phone?: string;
  orgs?: string; // JSON array
  grades?: string; // JSON array
  metadata?: Record<string, any>;
}

export interface OneRosterCourse {
  sourcedId: string;
  status: 'active' | 'tobedeleted';
  dateLastModified: string;
  schoolYearSourcedId?: string;
  title: string;
  courseCode: string;
  grades?: string; // JSON array
  subjects?: string; // JSON array
  orgSourcedId: string;
}

export interface OneRosterClass {
  sourcedId: string;
  status: 'active' | 'tobedeleted';
  dateLastModified: string;
  title: string;
  classCode: string;
  classType: 'homeroom' | 'scheduled';
  location?: string;
  grades?: string; // JSON array
  subjects?: string; // JSON array
  courseSourcedId: string;
  schoolSourcedId: string;
  termSourcedIds?: string; // JSON array
  periods?: string; // JSON array
}

export interface OneRosterEnrollment {
  sourcedId: string;
  status: 'active' | 'tobedeleted';
  dateLastModified: string;
  classSourcedId: string;
  schoolSourcedId: string;
  userSourcedId: string;
  role: 'student' | 'teacher';
  primary: boolean;
  beginDate?: string;
  endDate?: string;
}
```

### utils/logger.ts
```typescript
import { DefaultAzureCredential } from '@azure/identity';
import { LogsIngestionClient } from '@azure/monitor-ingestion';

interface LogEntry {
  timestamp: string;
  level: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL';
  component: string;
  message: string;
  properties: Record<string, any>;
  error?: {
    message: string;
    stack?: string;
  };
}

export class StructuredLogger {
  private component: string;
  private appInsightsClient?: LogsIngestionClient;

  constructor(componentName: string) {
    this.component = componentName;

    // Application InsightsÁµ±Âêà
    const connectionString = process.env.APPLICATIONINSIGHTS_CONNECTION_STRING;
    if (connectionString) {
      const credential = new DefaultAzureCredential();
      // „É≠„Ç∞Âèñ„ÇäËæº„Åø„ÇØ„É©„Ç§„Ç¢„É≥„ÉàÂàùÊúüÂåñ
      // this.appInsightsClient = new LogsIngestionClient(...);
    }
  }

  info(message: string, properties: Record<string, any> = {}): void {
    this.log('INFO', message, properties);
  }

  warning(message: string, properties: Record<string, any> = {}): void {
    this.log('WARNING', message, properties);
  }

  error(
    message: string,
    properties: Record<string, any> = {},
    error?: Error
  ): void {
    const errorInfo = error ? {
      message: error.message,
      stack: error.stack
    } : undefined;

    this.log('ERROR', message, properties, errorInfo);
  }

  private log(
    level: LogEntry['level'],
    message: string,
    properties: Record<string, any>,
    error?: LogEntry['error']
  ): void {
    const logEntry: LogEntry = {
      timestamp: new Date().toISOString(),
      level,
      component: this.component,
      message,
      properties,
      error
    };

    // „Ç≥„É≥„ÇΩ„Éº„É´Âá∫ÂäõÔºà„É≠„Éº„Ç´„É´ÈñãÁô∫Áî®Ôºâ
    console.log(JSON.stringify(logEntry));

    // Application Insights„Å∏ÈÄÅ‰ø°ÔºàÊú¨Áï™Áí∞Â¢ÉÔºâ
    if (this.appInsightsClient) {
      // ÂÆüË£Ö: „Ç´„Çπ„Çø„É†„É≠„Ç∞Âèñ„ÇäËæº„Åø
    }
  }
}
```

---

## üìù Ê¨°„ÅÆ„Éâ„Ç≠„É•„É°„É≥„Éà

- [05_data_flow_design.md](./05_data_flow_design.md) - „Éá„Éº„Çø„Éï„É≠„ÉºË©≥Á¥∞Ë®≠Ë®à

---

**ÊñáÊõ∏ÁÆ°ÁêÜË≤¨‰ªªËÄÖ**: System Architect  
**ÊúÄÁµÇÊõ¥Êñ∞Êó•**: 2025-10-27  
**„Éâ„Ç≠„É•„É°„É≥„Éà„Çπ„ÉÜ„Éº„Çø„Çπ**: Draft
